# 恒定吞吐量控制验证 - 参数与理论计算值

## 📋 实验配置参数

| 参数 | 配置值 | 来源 |
|------|--------|------|
| **任务执行时长** | 10 秒/任务 | `application-docker.yml: task.processing.duration-seconds=10` |
| **消费线程池大小** | 10 线程 | `application-docker.yml: rocketmq.consumer.consume-thread-min=10` |
| **测试任务总数** | 100 个任务 | `stress-test.sh: TOTAL_TASKS=100` |
| **任务类型** | DATA_EXPORT | 固定类型 |
| **提交方式** | 快速批量提交 | Shell 脚本循环调用 |

---

## 🧮 理论计算值

### 1. 吞吐量计算

**公式**：
```
吞吐量（任务/小时）= (3600秒 / 任务执行时间) × 线程数
```

**计算**：
```
吞吐量 = (3600 / 10) × 10
       = 360 × 10
       = 3600 任务/小时
```

**换算为其他单位**：
- **任务/分钟**: 3600 ÷ 60 = **60 任务/分钟**
- **任务/秒**: 3600 ÷ 3600 = **1 任务/秒**
- **秒/任务**: 10 ÷ 10 = **1 秒/任务** （平均每秒完成 1 个任务）

---

### 2. 完成时间计算

**公式**：
```
总完成时间 = (任务总数 / 线程数) × 任务执行时间 + 启动延迟
```

**计算**：
```
理论完成时间 = (100 / 10) × 10 + 启动延迟
             = 10 × 10 + 5-10秒
             = 100 + 10（估算）
             = 110 秒（约 1.83 分钟）
```

**详细过程**：
1. **第 1 批（0-10秒）**: 10 个任务并行处理
2. **第 2 批（10-20秒）**: 另外 10 个任务
3. **第 3 批（20-30秒）**: 10 个任务
4. ...
5. **第 10 批（90-100秒）**: 最后 10 个任务

**预期**：约 **90-110 秒**完成所有 100 个任务

---

### 3. 并发度预期

**最大并发数**: 10（受限于线程池大小）

**并发度曲线预期**：
```
活跃任务数
  12 |                                    (边界情况可能短暂达到 11-12)
  10 |    ████████████████████████████   (大部分时间保持在 10)
   8 |
   6 |
   4 |
   2 |
   0 |____________________________________
     0s   20s   40s   60s   80s   100s  时间
```

**预期行为**：
- 前几秒：快速上升到 10
- 中间阶段：稳定在 10（平台期）
- 最后阶段：逐渐下降到 0

---

### 4. 消息堆积预期

**RocketMQ Console 预期指标**：

| 时间点 | 消息堆积量 | 说明 |
|--------|-----------|------|
| **提交完成时**（~5秒） | ~100 条 | 所有任务已入队 |
| **30 秒后** | ~70 条 | 已处理 ~30 条 |
| **60 秒后** | ~40 条 | 已处理 ~60 条 |
| **90 秒后** | ~10 条 | 已处理 ~90 条 |
| **110 秒后** | 0 条 | 全部处理完成 |

**消费速率**：
- **理论消费速率**: 60 消息/分钟（恒定）
- **预期**: 即使堆积 100 条，消费速率仍保持 60/分钟不变

---

## 📊 验证指标与预期值

| 指标 | 理论值 | 允许误差范围 | 实际测量方法 |
|------|--------|--------------|--------------|
| **吞吐量** | 1 任务/秒 | ±20% (0.8-1.2) | 完成任务数 / 总时间 |
| **最大并发数** | 10 | ±2 (8-12) | 日志中 activeTasks 最大值 |
| **完成时间** | 110 秒 | ±20% (88-132秒) | 最后任务完成时间 - 首任务开始时间 |
| **消费速率** | 60 消息/分钟 | ±20% | RocketMQ Console 观察 |

---

## 🎯 验证成功的标准

✅ **核心验证点**：

1. **并发数控制**:
   - activeTasks 峰值 ≤ 12（考虑边界情况）
   - 大部分时间稳定在 10 附近

2. **吞吐量恒定**:
   - 实际吞吐量在 0.8-1.2 任务/秒范围内
   - 即使任务堆积，处理速率不波动

3. **完成时间可预测**:
   - 100 个任务在 88-132 秒内完成
   - 符合理论公式：任务数 / 线程数 × 时长

4. **资源使用稳定**:
   - CPU 使用率保持稳定（不会因任务堆积而线性增长）
   - 内存使用稳定

---

## 🔍 RocketMQ Dashboard 监控要点

访问 http://localhost:8081，观察以下指标：

### 1. 消息堆积趋势
**路径**: 消息 → 消息消息 → 选择 Topic: `task-topic`

**预期曲线**:
```
堆积量
 100 |●
  90 | ●
  80 |  ●
  70 |   ●
  60 |    ●
  50 |     ●
  40 |      ●
  30 |       ●
  20 |        ●
  10 |         ●
   0 |          ●________________________
     0s   20s   40s   60s   80s   100s  120s
```

### 2. 消费者组状态
**路径**: 消费者 → 消费者组 → 选择: `task-consumer-group`

**关键指标**:
- **消费延迟**: 先增大后减小
- **消费TPS**: 稳定在 ~1 消息/秒
- **Rebalance**: 不应该频繁出现

### 3. 消息详情
**路径**: 消息 → 消息查询 → Topic: `task-topic`

可以查看：
- 消息总数（应为 100）
- 消费状态（已消费/未消费）

---

## 📝 实验步骤

### 准备工作
1. 确保 Docker 容器运行: `docker-compose ps`
2. 检查健康状态: `curl http://localhost:8080/health`
3. 访问 RocketMQ Console: http://localhost:8081

### 执行测试
```bash
# 1. 提交 100 个任务
./stress-test.sh

# 2. 实时监控（可选，另开一个终端）
docker logs -f task-app | grep -E "(Task started|Task executed|activeTasks)"

# 3. 等待约 2 分钟后，分析结果
./analyze-logs.sh ./stress-test-results/submissions_*.txt
```

### 验证检查清单
- [ ] 任务总数 = 100
- [ ] 最大并发数 ≤ 12
- [ ] 完成时间在 88-132 秒之间
- [ ] 吞吐量在 0.8-1.2 任务/秒
- [ ] RocketMQ Console 显示消息堆积先升后降
- [ ] 消费 TPS 稳定在 ~60/分钟

---

## 🎓 理论基础

### 为什么固定线程池能实现恒定吞吐？

**核心原理**: RocketMQ 的自动背压机制

1. **线程池满时**: RocketMQ 暂停推送新消息
2. **线程释放后**: 继续推送消息
3. **结果**: 实际并发数 = 线程池大小

**类比**：
- 就像一个餐厅有 **10 个服务员**
- 即使有 100 个顾客排队，同时服务的只有 10 个
- **服务速率** = 10 人 × (1 人 / 10 秒) = 1 人/秒（恒定）

### 公式推导

```
系统吞吐量 = 单个任务处理速率 × 并行度

其中：
- 单个任务处理速率 = 1 / 任务执行时间
- 并行度 = 线程池大小

因此：
吞吐量 = (1 / 10秒) × 10 = 0.1 任务/秒 × 10 = 1 任务/秒
```

---

## 🚨 注意事项

1. **第一次运行时**: RocketMQ 可能需要预热，前几个任务可能稍慢
2. **时间精度**: 日志时间戳精度到毫秒，但系统调度可能有微小偏差
3. **边界情况**: activeTasks 可能在任务切换时短暂达到 11（正常的边界效应）
4. **日志覆盖**: 如果容器运行很久，日志可能很多，建议测试前清空或使用日志分析脚本

---

## 📁 输出文件说明

运行测试后会生成以下文件：

| 文件 | 说明 |
|------|------|
| `stress-test-results/submissions_*.txt` | 任务提交记录（taskId + 时间戳）|
| `stress-test-results/docker_logs_*.txt` | Docker 容器完整日志 |
| `stress-test-results/analysis_*.txt` | 分析报告汇总 |

---

**准备就绪！运行 `./stress-test.sh` 开始测试。** 🚀
